% MakeFigureBestFlowFieldFits
% Script to generate flow field plots from data and optic flow fields
% obtained by fitting a self-motion optic flow to the data.
% Requires data generated by the script:
% - T4T5_fitFlowField_expanded_CV
% Produces figures used in figure 4 and exended data figure 5 in 
% Henning, Ramos-Traslosheros et al.

%%
% 
%  Copyright 2020 Giordano Ramos-Traslosheros
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
% 
% 1. Redistributions of source code must retain the above copyright notice,
% this list of conditions and the following disclaimer.
% 
% 2. Redistributions in binary form must reproduce the above copyright
% notice, this list of conditions and the following disclaimer in the
% documentation and/or other materials provided with the distribution.
% 
% 3. Neither the name of the copyright holder nor the names of its
% contributors may be used to endorse or promote products derived from this
% software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
% IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
% CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

close all;
clearvars;
clc;

%% move to parent directory
codeDir = pwd;
[parentDir, ~] = fileparts(pwd);
cd(parentDir);
addpath(genpath(codeDir));
%% Load data
load(['Input_data' filesep 't4t5_flowFields.mat']);
%% set output path
outputDir = 'Model_figures';
if ~exist(['.' filesep outputDir], 'dir'); mkdir(outputDir); end
set(groot, 'DefaultFigureVisible', 'on');
set(groot, 'DefaultFigureWindowStyle', 'normal'); 

%% Load fit data
fileName = 'flowFitsCV10FoldRand';
load(['Model_output' filesep fileName '.mat']);
figDir = [outputDir filesep 'flowAnalysis'];
if ~exist(figDir, 'dir'); mkdir(figDir); end

%%
DataCell = {[Coord_T4A_I Coord_T5A_I], [Quiver_T4A_I Quiver_T5A_I];
            [Coord_T4A_II Coord_T5A_II], [Quiver_T4A_II Quiver_T5A_II]; 
			[Coord_T4B_I Coord_T5B_I], [Quiver_T4B_I Quiver_T5B_I];
			[Coord_T4B_II Coord_T5B_II], [Quiver_T4B_II Quiver_T5B_II];
			[Coord_T4C Coord_T5C], [Quiver_T4C Quiver_T5C];
			[Coord_T4D Coord_T5D], [Quiver_T4D Quiver_T5D]};
FilenameCell = {'LayerA1', 'LayerA2', 'LayerB1', 'LayerB2', 'LayerC', 'LayerD'};
%%
nCellTypes = size(DataCell, 1);
% plot original optic flow vectors in correct axis 
nModels = size(vTCell, 2);
nKCrossValidation = size(vTCell, 3);
% this were not stored in metadata but are needed if it script is modified.
normalizeData = 0;
interpData = 0;
nRepeats = 10; % not stored in metadata.

%%

% Array with location of best cv fold fit.
[~, minCVFold] = min(lossArray, [], 3);

% Plot results
figDir = [outputDir filesep 'flowFigsPaper'];
if ~exist(figDir, 'dir'); mkdir(figDir); end
% hFig(1) = figure('Position', [0 0 600 200], 'Visible', 'off');


%%
close all
hFig(1) = figure('Position', [0 0 500 6*500/3], 'Visible', 'on');
hFig(2) = figure('Position', [0 0 500 6*500], 'Visible', 'on');

figure(hFig(1))
for iLayer = 1: nCellTypes
    hSubAx(1, iLayer) = subplot(2*6, 6, 6 * 2 * (iLayer - 1) + [1: 4, 7: 10]);
    hSubAx(2, iLayer) = subplot(2*6, 6, 6 * 2 * (iLayer - 1) + [5, 6, 11, 12]);
end

figure(hFig(2))
for iLayer = 1: nCellTypes
    hSubAxFull(iLayer) = subplot(6, 1, iLayer);
end

for iLayer = 1: nCellTypes
    XAll = DataCell{iLayer, 1};
    VAll = DataCell{iLayer, 2};
    jFlowType = 0;
    kRun = minCVFold(iLayer, jFlowType + 1);

    crossValInds = crossValIndsCell{iLayer};
    testInds = (crossValInds == kRun);
    X.train = XAll(:, ~testInds);
    X.test = XAll(:, testInds);
    V.train = VAll(~testInds);
    V.test = VAll(testInds);
    flowType = jFlowType;
%     fileName = [FilenameCell{iLayer} ...
%                 '-Interp' num2str(interpData, '%d') ...
%                 '-Norm' num2str(normalizeData, '%d') ...
%                 '-FlowType' num2str(flowType, '%d')];
    fileName = ['AllLayers' ...
                '-Interp' num2str(interpData, '%d') ...
                '-Norm' num2str(normalizeData, '%d') ...
                '-FlowType' 'All'];            
    
    vT = vTCell{iLayer, jFlowType + 1, kRun};
    vR = vRCell{iLayer, jFlowType + 1, kRun};
    vUni = vUniCell{iLayer, jFlowType + 1, kRun};
    loss = lossArray(iLayer, jFlowType + 1, kRun);
        
    [phiData.train, thetaData.train, rData.train, uData.train, vData.train] = ...
    	getT4T5Data(X.train, V.train, interpData, normalizeData);
    [phiData.test, thetaData.test, rData.test, uData.test, vData.test] = ...
    	getT4T5Data(X.test, V.test, interpData, normalizeData);
    
    phiDataAll = [phiData.train, phiData.test];
    thetaDataAll = [thetaData.train, thetaData.test];
    rDataAll = [rData.train, rData.test];
    uDataAll = [uData.train, uData.test];
    vDataAll = [vData.train, vData.test];

    if flowType ~= 3
        [phiFit, thetaFit, uFit, vFit] = calculateSphereFlow(deg2rad(phiDataAll), ...
                                                             deg2rad(thetaDataAll), ...
                                                             rDataAll, vT, vR);
    else
        [phiFit, thetaFit, uFit, vFit] = deal(phiDataAll, thetaDataAll, ...
                                               vUni(1) * ones(size(phiDataAll)), ...
                                               vUni(2) * ones(size(phiDataAll)));
        vT(1: 3) = nan;
        vR(1: 3) = nan;
        vT(1: 2) = vUni;
    end


%     set(0, 'currentfigure', hFig(1));
    plotFlowDataAndFit(hSubAx(1, iLayer), phiDataAll, thetaDataAll, uDataAll, vDataAll, phiFit, thetaFit, uFit, vFit, vT, vR, loss)
    hSubAx(1, iLayer).XLim = [-40 120];
    hSubAx(1, iLayer).YLim = [-20 40];
    hSubAx(1, iLayer).TickDir = 'out';
    hSubAx(1, iLayer).YTick = -20: 20: 40;
    hSubAx(1, iLayer).XTick = -40: 40: 120;
    hSubAx(1, iLayer).Box = 'off';
    
    plotSphereFlow(hSubAx(2, iLayer), vT, vR)
    hSubAx(2, iLayer).XLim = [-1 1];
    hSubAx(2, iLayer).YLim = [-1 1];
    hSubAx(2, iLayer).ZLim = [-1 1];
    hSubAx(2, iLayer).TickDir = 'out';
    hSubAx(2, iLayer).Box = 'off';
    hSubAx(2, iLayer).View = [-45 30];
    hSubAx(2, iLayer).PlotBoxAspectRatio = [1 1 1];

    plotFlowDataAndFitSphere(hSubAxFull(iLayer), phiDataAll, thetaDataAll, uDataAll, vDataAll, vT, vR, loss);
    hSubAxFull(iLayer).XLim = [-40 120];
    hSubAxFull(iLayer).YLim = [-45 45];
    hSubAxFull(iLayer).YTick = -20: 20: 40;
    hSubAxFull(iLayer).XTick = -40: 40: 120;
    hSubAxFull(iLayer).DataAspectRatio = [1 1 1];
%     print(gcf, [figDir filesep fileName '-Full.pdf'], '-dpdf')
    
end
%%
set(hFig, 'Renderer', 'painters');
print(hFig(1), [figDir filesep fileName '.pdf'], '-dpdf')
print(hFig(2), [figDir filesep fileName '-FullField' '.pdf'], '-dpdf')
cd(codeDir)
%%

function plotFlowDataAndFit(hAx, phiData, thetaData, uData, vData, phiFit, thetaFit, uFit, vFit, vT, vR, loss)
	axes(hAx)
	validPoints = ~isnan(uData) & ~isnan(vData);
	hQFit = quiver(phiFit(validPoints), thetaFit(validPoints), ...
	               uFit(validPoints), vFit(validPoints), 0.5, 'g');
	hold on;
	hQData = quiver(phiData(validPoints), thetaData(validPoints), ...
	                uData(validPoints), vData(validPoints), 0.5, 'Color', [1 0 1]);
	hQData.LineWidth = 1;
	hQFit.LineWidth = 1;
    statsString = sprintf(['T=[%0.1f,%0.1f,%0.1f]\n' ...
	               'R=[%0.1f,%0.1f,%0.1f]\nloss=%0.2f'], ...
	                vT(1), vT(2), vT(3), vR(1), vR(2), vR(3), loss);
% 	title(sprintf(['T = [%0.1f, %0.1f, %0.1f], ' ...
% 	               'R = [%0.1f, %0.1f, %0.1f], loss = %0.2f'], ...
% 	                vT(1), vT(2), vT(3), vR(1), vR(2), vR(3), loss));
    text(-35, -10, statsString, 'FontSize', 6);
	legend('Fit', 'Data', 'Location', 'southeast');
    legend('boxoff');
	xlabel('azimuth(deg)');
	ylabel('elevation(deg)');
end

function plotFlowDataAndFitSphere(hAx, phiData, thetaData, uData, vData, vT, vR, loss)
	phi = linspace(-pi, pi, 40);
	theta = linspace(-pi/2, pi/2, 20);
	[phi, theta] = meshgrid(phi, theta);
	r = ones(size(phi));
	[X, Y, Z] = sph2cart(phi, theta, r);

	isUniform = any(isnan([vT(:) vR(:)]));

	if ~isUniform
		[phiDeg, thetaDeg, u, v] = calculateSphereFlow(phi, theta, r, vT, vR);
    else
        vUni = vT(1: 2);
		[phiDeg, thetaDeg, u, v] = deal(rad2deg(phi), rad2deg(theta), ...
										vUni(1) * ones(size(phi)), ...
										vUni(2) * ones(size(phi)));
	end

	axes(hAx)
	hQ = quiver(phiDeg, thetaDeg, u, v, 0.5, 'g');
	hQ.LineWidth = 1;
	hold on;

% 	validPoints = ~isnan(uData) & ~isnan(vData);
	validPoints = find(~isnan(uData) & ~isnan(vData));
    % discard some data to make it more sparse in the plot
    percentDiscarded = 0;
    validPoints(randsample(numel(validPoints), round(percentDiscarded * numel(validPoints)))) = 0;
    validPoints = validPoints(validPoints ~= 0);
	hQData = quiver(phiData(validPoints), thetaData(validPoints), ...
	                uData(validPoints), vData(validPoints), 0.5, 'm');
	hQData.LineWidth = 1;
	hQ.LineWidth = 1;
    statsString = sprintf(['T=[%0.1f,%0.1f,%0.1f]\n' ...
	               'R=[%0.1f,%0.1f,%0.1f]\nloss=%0.2f'], ...
	                vT(1), vT(2), vT(3), vR(1), vR(2), vR(3), loss);
% 	title(sprintf(['T = [%0.1f, %0.1f, %0.1f], ' ...
% 	               'R = [%0.1f, %0.1f, %0.1f], loss = %0.2f'], ...
% 	                vT(1), vT(2), vT(3), vR(1), vR(2), vR(3), loss));
    text(-35, -10, statsString, 'FontSize', 6);
	legend('Fit', 'Data');
	xlabel('azimuth(deg)');
	ylabel('elevation(deg)');
end


function plotSphereFlow(hAx, vT, vR)
	phi = linspace(-pi, pi, 20);
	theta = linspace(-pi/2, pi/2, 10);
	[phi, theta] = meshgrid(phi, theta);
	r = ones(size(phi));
	[X, Y, Z] = sph2cart(phi, theta, r);
    
	isUniform = any(isnan([vT(:) vR(:)]));

	if ~isUniform
		[phiDeg, thetaDeg, u, v] = calculateSphereFlow(phi, theta, r, vT, vR);
    else
        vUni = vT(1: 2);
		[phiDeg, thetaDeg, u, v] = deal(rad2deg(phi), rad2deg(theta), ...
										vUni(1) * ones(size(phi)), ...
										vUni(2) * ones(size(phi)));
	end

	pTangential = zeros(numel(phiDeg), 3);
	for iP = 1: numel(phiDeg)
	    pTangential(iP, :) = sph2cartvec([u(iP); v(iP); 0], phiDeg(iP), thetaDeg(iP))';
	end

	axes(hAx)
	mesh(X, Y, Z, zeros(size(Z)));
	colormap('gray')
	hold on;
	for iPoint = 1: numel(X)
	    di = [X(iPoint) Y(iPoint) Z(iPoint)];
	    pVec = pTangential(iPoint, :);
	%     quiver3(0, 0, 0, di(1), di(2), di(3), 'k');
	    hold on
	    quiver3(di(1), di(2), di(3), pVec(1), pVec(2), pVec(3), 0.2, 'g', 'MaxHeadSize', 2);
	end
	xlabel('X');
	ylabel('Y');
	zlabel('Z');
end

function [phiData, thetaData, rData, uData, vData] = getT4T5Data(X, V, interpData, normalizeData)
    if interpData
        [Xq, Yq, Vq] = interpolateGridQuiver(X, V);
    else
        validInds = ~any(isnan(X), 1);
        Xq = X(2, validInds) - 34;
        Yq = X(1, validInds) + 36;
        Vq = V(validInds);
    end

    phiData = Xq;
    thetaData = Yq; 
    uData = real(Vq);
    vData = imag(Vq);
    rData = ones(size(phiData));

    if normalizeData
        normData = sqrt(uData .^ 2 + vData .^ 2);
        uData = uData ./ normData;
        vData = vData ./ normData;
    end
end

function [Xq, Yq, Vq] = interpolateGridQuiver(X, V) 
[Xq, Yq] = meshgrid(-35: 3: 45);
validInds = ~any(isnan(X), 1);
Vq = griddata(X(2, validInds) - 34, X(1, validInds) + 36, ...
              V(validInds), Xq, Yq, 'cubic');
       
end